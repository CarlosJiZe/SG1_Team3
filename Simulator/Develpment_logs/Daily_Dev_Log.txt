GreenGridSim — Development Log
Date: 2026-02-05
Team: Team 3

Member: Carlos Jimenez Zepeda

Summary
Today I created the base structure of the project and initialized the GitHub repository. I also implemented the first three core components of the digital twin as Python classes: Battery, CloudCoverage, and SolarPanel.

Work completed
1) Project setup
- Created the initial folder structure (src/, tests/, results/, Development_logs/, Personal_reflections/).
- Initialized the GitHub repository and pushed the base scaffold.

2) Core classes implemented (src/)
- Battery.py: battery model with capacity (kWh), minimum SoC constraint, and round-trip efficiency handling.
- CloudCoverage.py: seasonal cloud coverage generator using weighted probabilities and coverage ranges.
- SolarPanel.py: solar generation model based on time-of-day and cloud coverage reduction.

3) Testing and verification (tests/)
- I used AI assistance to generate initial test files to validate that my implementation behaved correctly (basic sanity checks for charge/discharge behavior, seasonal cloud distributions, and solar generation across different hours).
- During testing, I noticed the solar generation function was producing weird/unrealistic values. The AI helped me identify why the formula/mapping was wrong and guided me to correct the time-to-angle setup so the curve behaves as expected (zero at night, peak around midday) and then apply cloud coverage as a proportional reduction.
- This was very helpful because it confirmed my code was working and clarified the reason behind the incorrect results I was seeing.

Notes / Issues
- Main issue today was the incorrect solar generation behavior due to the initial formula setup. After fixing the mapping and re-running tests, results became consistent with expectations.

Next steps
- Implement Inverter class with clipping and failure simulation
- Implement Load class with base + random spikes
- Implement Grid class with import/export tracking

Date: 2026-02-06  
Team: Team 3  

Member: Carlos Jimenez Zepeda

Summary
Today I completed three additional core components for the digital twin: Inverter, Load, and Grid. I also enhanced the Load class to include scheduled events for more realistic household consumption patterns. All components were tested and are working correctly.

Work Completed
1) Core classes implemented (src/)
- Inverter.py: Solar inverter with power clipping (4 kW max) and random failure simulation (0.5% daily probability, 4-72 hour duration with state tracking).
- Load.py: Household consumption model with four components: base load (0.5 kW constant), scheduled events (morning coffee, lunch, etc. with individual probabilities), peak hours (6-9 PM high consumption), and random noise (30% probability of small spikes).
- Grid.py: Energy import/export with the utility grid, including cost tracking ($0.0075/kWh import, $0.009/kWh export), 20 kW export limit, and net balance calculation.

2) Design decisions
- Enhanced Load class beyond simple peak hours to include scheduled events at specific times (6 AM coffee, 12 PM lunch, etc.). This provides more realistic variability by combining base + scheduled + peak + random noise components.
- Clarified export limit interpretation: 20 kW is an instantaneous power limit (not cumulative). With 1-hour time steps, this means max 20 kWh per hour with no daily/monthly accumulation.
- Decided to keep Grid class simple (transactions only) and save energy management strategies for a separate EnergyManagementSystem class (next session).

3) Testing and verification
- I used AI assistance to help implement and test all three classes.
- Inverter tests confirmed clipping works correctly (5 kW → 4 kW output) and failures occur at expected rate (~1 per 200 days).
- Load tests showed scheduled events occurring at correct probabilities and realistic daily consumption patterns (avg 2.6 kW during peak hours, max 4.2 kW).
- Grid tests validated import/export calculations, export limit enforcement, and net balance accuracy.

Notes / Issues
- Main learning was understanding the difference between scheduled events (time-specific, high probability) versus random noise (anytime, low probability) for realistic load modeling.
- Had to clarify the export limit units (kW vs kWh) through careful analysis of the document wording and real-world context.
- Test simulation showing negative net balance is realistic and expected when importing more energy overnight than exporting during peak solar hours.

Next Steps
- Implement EnergyManagementSystem class with three priority strategies (LOAD_PRIORITY, CHARGE_PRIORITY, PRODUCE_PRIORITY)
- Create main Simulation class using SimPy for discrete-event simulation
- Integrate all components into time-stepped simulation loop

Date: 2026-02-07  
Team: Team 3

Member: Carlos Jimenez Zepeda  

Summary
Today I completed the most complex component of the project: the EnergyManagementSystem (EMS). This "brain" of the system manages energy distribution across three different priority strategies and implements automatic curtailment logic. I also clarified important design decisions about zero export policies and unmet load tracking through detailed discussions about system behavior.

Work Completed

1) Core class implemented (src/)

EnergyManagementSystem.py:
- Implemented three priority strategies for energy distribution:
  - LOAD_PRIORITY: Prioritizes house load first, then battery charging, then grid export
  - CHARGE_PRIORITY: Prioritizes battery charging first, then house load, then grid export
  - PRODUCE_PRIORITY: Prioritizes grid export first (up to 20 kW limit), then battery, then house load
- Automatic curtailment when battery is full and excess solar would be exported

2) Design decisions and clarifications

Unmet Load Interpretation:
- Initially unclear whether "unmet load" meant total system failure or grid dependency
- Clarified that unmet_load = grid_to_load (energy that solar+battery couldn't provide)
- This metric measures system self-sufficiency: higher unmet load = more grid dependent
- Important distinction: with unlimited grid, loads are always met, but internal system may fail to provide

3) Testing and verification

Comprehensive test suite created (tests/testEMS.py):
- Tested all three strategies with multiple scenarios each
- Verified curtailment behavior (battery full vs not full)
- Tested zero export policy (grid limit = 0)
- Verified unmet load tracking with empty battery scenarios
- Confirmed financial calculations for PRODUCE_PRIORITY

Notes / Issues

Main learnings:
- Understanding "unmet load" as a measure of system self-sufficiency (not total failure) was crucial for proper implementation
- Strategy differences primarily affect behavior during excess solar generation, not deficit handling
- Curtailment serves multiple purposes: respecting grid limits, preventing equipment wear, enforcing zero-export policies
- Financial arbitrage in PRODUCE_PRIORITY is counterintuitive but economically rational

Next Steps

Immediate (next session):
- Implement Simulation class using SimPy for discrete-event simulation
- Integrate all 7 completed components (Battery, SolarPanel, CloudCoverage, Inverter, Load, Grid, EMS)
- Create main simulation loop with hourly time steps

Date: 2026-02-08  
Team: Team 3  

Member: Carlos Jimenez Zepeda  

Summary
Today marks a major milestone: I successfully integrated all individual components into the main simulation engine and created the execution scripts. I also implemented a robust configuration system using JSON files and a data logging system that automatically generates structured results. The Digital Twin is now fully operational.

Work Completed
1) Simulation orchestration (src/)
- Simulation.py: Implemented the main class using SimPy. This orchestrator initializes all components (Battery, Grid, Solar, etc.) based on the configuration and runs the discrete-event loop step-by-step.
- DataLogger.py: Created a dedicated class to handle data collection during the simulation and export it to CSV (hourly data) and JSON (summaries) within the results/ folder.

2) Execution & analysis tools
- main.py: The primary entry point. It loads the config.json, initializes the simulation, runs it, and triggers the data logger.
- compare_strategies.py: A utility script that runs multiple simulations back-to-back while maintaining the same random seed. This allows for scientifically valid comparisons as required by the project rubric.
- Configuration: Created config.json and config_template.json to allow parameter tuning without changing code.

3) Testing and AI assistance
- I used AI assistance to implement the JSON parameter parsing logic, ensuring robust error handling when reading configuration values.
- The AI also helped design the DataLogger logic to dynamically create result folders with timestamps and save reports in the correct structure.
- Generated tests for Simulation.py to verify that the time-steps progress correctly and that the final summary statistics match the accumulated hourly data.

Notes / Issues
- Initial runs showed high energy deficits. After analyzing the logs, I confirmed the code was correct; the issue was that the default "1 solar panel + 1 battery" setup is undersized for the simulated load. This validates the Digital Twin's purpose (identifying sizing issues before deployment).
- Ensured that the random_seed in the JSON config correctly forces the same weather/load patterns, which is critical for the comparison script.

Next Steps
- Run the final set of simulations to answer the 15 project questions.
- Compile the final report summarizing design choices and strategy comparisons.
- Write personal reflections and clean up code for final submission.


Date: 2026-02-8
Team: Team 3  

Member: Martín García

Summary: 
Today was the testing of the code and searching for problems with some configs or parameters.

Work Completed:

1) Check that the code has all the escenarios posible:
-Try absurds values like 0 days, 1000 hours, 0.00001 kW
-See if the code has all the detection if this problems and gives a warning before crash the code

2)Review and testing:
-See all the files and make sure all the thing are working as intended
-Try new cases or values in the config

3)Add to .gitignore the results:
-Make the results to stay in the computer and not pushed in the GitHub


Date: 2026-02-09  
Team: Team 3  

Member: Carlos Jimenez Zepeda  

Summary
Today was dedicated to debugging and verification. After running test simulations, I noticed unusual energy values and inconsistent self-sufficiency percentages. I used AI assistance to conduct a thorough code review that identified 7 potential bugs. I successfully fixed 6 critical issues affecting energy balance, battery efficiency, and metric calculations. The 7th was a nomenclature clarification, not an actual bug.

Work Completed

1) Critical bugs fixed (Simulation.py, Battery.py, DataLogger.py)
- Fixed day change detection using modulo-based logic instead of old step values
- Corrected curtailed energy accounting (was being counted as generated solar)
- Fixed inverter.update() to run every timestep instead of once per day (allows sub-day failures)
- Corrected self-sufficiency formula from `((solar - import)/load) * 100` to `(1 - import/load) * 100`
- Modified Battery.charge() to return energy CONSUMED from source (including efficiency losses), not energy stored
- Replaced hardcoded battery thresholds with config-based values

2) Verification and validation
- Re-ran 30-day simulation with same seed (519425893)
- Energy balance improved from ~13.66 kWh error to 0.000009 kWh (essentially perfect)
- Confirmed all 720 timesteps respect battery limits (5%-100%)
- Validated consistency between hourly_data.csv, answers.txt, and comparison_report.txt

3) Format corrections and condition restoration
- Had to revert some initial fixes that broke simulation flow
- Restored previous working conditions but with corrected logic
- Learned to make incremental changes and test after each one

Notes / Issues

Main learnings:
- Energy conservation is critical - small accounting errors compound over time
- Battery efficiency is subtle: must distinguish energy consumed vs stored vs rejected
- Curtailment = generation PREVENTED (not generated then wasted)
- Had to revert and retry fixes when first attempts broke cloud coverage update timing

AI assistance helped identify the battery efficiency bug (BUG 5) which was the most subtle - efficiency losses were being treated as exportable energy instead of heat loss.

Next Steps
- Run final verification with multiple random seeds
- Write personal reflection about debugging process
- Prepare final report with corrected metrics for submission



Date: 2026-02-10
Team: Team 3

Member: Martin García

Summary:
See the changes and rerun some test and cases after all the corrections

Work completed:

1)Try to break the code:
-Again use absurd values to check the output of the code
-Use variables that are not allowed in the config

2)Rerun some previous conifs:
-Use the configs i used in previous days
-Check if the data changed and what changed
-In case the data doesnt change see if its correct

3)Start with the README file:
-Start dividing all the sections in the code
-Add text of how does the code working

Date: 2026-02-11
Team: Team 3

Member: Martin García

Summary: 
Finish the README File

Work completed:

1)Finish writing the README file:
- Add:
  * [Features]
  * [Quick Start]
  * [Installation]
  * [Configuration]
  * [Usage](#-usage)
  * [Project Structure]
  * [Output Files]
  * [Advanced Usage]
  * [Troubleshooting]
  * [Future Phases]
- Organize all the info 
-Add the index of all the README
-Check the grammar of the file
-See if the instructions are cristal clear
-Add the Troubleshooting that is commond and how to fix it
-Add the LICENSE already in the project to it
