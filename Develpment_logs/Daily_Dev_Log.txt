GreenGridSim — Development Log
Date: 2026-02-05
Team: Team 3

Member: Carlos Jimenez Zepeda

Summary
Today I created the base structure of the project and initialized the GitHub repository. I also implemented the first three core components of the digital twin as Python classes: Battery, CloudCoverage, and SolarPanel.

Work completed
1) Project setup
- Created the initial folder structure (src/, tests/, results/, Development_logs/, Personal_reflections/).
- Initialized the GitHub repository and pushed the base scaffold.

2) Core classes implemented (src/)
- Battery.py: battery model with capacity (kWh), minimum SoC constraint, and round-trip efficiency handling.
- CloudCoverage.py: seasonal cloud coverage generator using weighted probabilities and coverage ranges.
- SolarPanel.py: solar generation model based on time-of-day and cloud coverage reduction.

3) Testing and verification (tests/)
- I used AI assistance to generate initial test files to validate that my implementation behaved correctly (basic sanity checks for charge/discharge behavior, seasonal cloud distributions, and solar generation across different hours).
- During testing, I noticed the solar generation function was producing weird/unrealistic values. The AI helped me identify why the formula/mapping was wrong and guided me to correct the time-to-angle setup so the curve behaves as expected (zero at night, peak around midday) and then apply cloud coverage as a proportional reduction.
- This was very helpful because it confirmed my code was working and clarified the reason behind the incorrect results I was seeing.

Notes / Issues
- Main issue today was the incorrect solar generation behavior due to the initial formula setup. After fixing the mapping and re-running tests, results became consistent with expectations.

Next steps
- Implement Inverter class with clipping and failure simulation
- Implement Load class with base + random spikes
- Implement Grid class with import/export tracking

Date: 2026-02-06  
Team: Team 3  

Member: Carlos Jimenez Zepeda

Summary
Today I completed three additional core components for the digital twin: Inverter, Load, and Grid. I also enhanced the Load class to include scheduled events for more realistic household consumption patterns. All components were tested and are working correctly.

Work Completed
1) Core classes implemented (src/)
- Inverter.py: Solar inverter with power clipping (4 kW max) and random failure simulation (0.5% daily probability, 4-72 hour duration with state tracking).
- Load.py: Household consumption model with four components: base load (0.5 kW constant), scheduled events (morning coffee, lunch, etc. with individual probabilities), peak hours (6-9 PM high consumption), and random noise (30% probability of small spikes).
- Grid.py: Energy import/export with the utility grid, including cost tracking ($0.0075/kWh import, $0.009/kWh export), 20 kW export limit, and net balance calculation.

2) Design decisions
- Enhanced Load class beyond simple peak hours to include scheduled events at specific times (6 AM coffee, 12 PM lunch, etc.). This provides more realistic variability by combining base + scheduled + peak + random noise components.
- Clarified export limit interpretation: 20 kW is an instantaneous power limit (not cumulative). With 1-hour time steps, this means max 20 kWh per hour with no daily/monthly accumulation.
- Decided to keep Grid class simple (transactions only) and save energy management strategies for a separate EnergyManagementSystem class (next session).

3) Testing and verification
- I used AI assistance to help implement and test all three classes.
- Inverter tests confirmed clipping works correctly (5 kW → 4 kW output) and failures occur at expected rate (~1 per 200 days).
- Load tests showed scheduled events occurring at correct probabilities and realistic daily consumption patterns (avg 2.6 kW during peak hours, max 4.2 kW).
- Grid tests validated import/export calculations, export limit enforcement, and net balance accuracy.

Notes / Issues
- Main learning was understanding the difference between scheduled events (time-specific, high probability) versus random noise (anytime, low probability) for realistic load modeling.
- Had to clarify the export limit units (kW vs kWh) through careful analysis of the document wording and real-world context.
- Test simulation showing negative net balance is realistic and expected when importing more energy overnight than exporting during peak solar hours.

Next Steps
- Implement EnergyManagementSystem class with three priority strategies (LOAD_PRIORITY, CHARGE_PRIORITY, PRODUCE_PRIORITY)
- Create main Simulation class using SimPy for discrete-event simulation
- Integrate all components into time-stepped simulation loop

Date: 2026-02-07  
Team: Team 3

Member: Carlos Jimenez Zepeda  

Summary
Today I completed the most complex component of the project: the EnergyManagementSystem (EMS). This "brain" of the system manages energy distribution across three different priority strategies and implements automatic curtailment logic. I also clarified important design decisions about zero export policies and unmet load tracking through detailed discussions about system behavior.

Work Completed

1) Core class implemented (src/)

EnergyManagementSystem.py:
- Implemented three priority strategies for energy distribution:
  - LOAD_PRIORITY: Prioritizes house load first, then battery charging, then grid export
  - CHARGE_PRIORITY: Prioritizes battery charging first, then house load, then grid export
  - PRODUCE_PRIORITY: Prioritizes grid export first (up to 20 kW limit), then battery, then house load
- Automatic curtailment when battery is full and excess solar would be exported

2) Design decisions and clarifications

Unmet Load Interpretation:
- Initially unclear whether "unmet load" meant total system failure or grid dependency
- Clarified that unmet_load = grid_to_load (energy that solar+battery couldn't provide)
- This metric measures system self-sufficiency: higher unmet load = more grid dependent
- Important distinction: with unlimited grid, loads are always met, but internal system may fail to provide

3) Testing and verification

Comprehensive test suite created (tests/testEMS.py):
- Tested all three strategies with multiple scenarios each
- Verified curtailment behavior (battery full vs not full)
- Tested zero export policy (grid limit = 0)
- Verified unmet load tracking with empty battery scenarios
- Confirmed financial calculations for PRODUCE_PRIORITY

Notes / Issues

Main learnings:
- Understanding "unmet load" as a measure of system self-sufficiency (not total failure) was crucial for proper implementation
- Strategy differences primarily affect behavior during excess solar generation, not deficit handling
- Curtailment serves multiple purposes: respecting grid limits, preventing equipment wear, enforcing zero-export policies
- Financial arbitrage in PRODUCE_PRIORITY is counterintuitive but economically rational

Next Steps

Immediate (next session):
- Implement Simulation class using SimPy for discrete-event simulation
- Integrate all 7 completed components (Battery, SolarPanel, CloudCoverage, Inverter, Load, Grid, EMS)
- Create main simulation loop with hourly time steps